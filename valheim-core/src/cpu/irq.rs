use crate::cpu::{PrivilegeMode, RV64Cpu};
use crate::cpu::csr::CSRMap::{MEIP_MASK, MIE, MIP, MSIP_MASK, MSTATUS, MTIP_MASK, SEIP_MASK, SSIP_MASK, SSTATUS, STIP_MASK};
use crate::isa::compressed::untyped::Bytecode16;
use crate::isa::untyped::Bytecode;
use crate::memory::VirtAddr;

enum IRQ {
  /// Machine external IRQ
  MEI,
  /// Machine software IRQ
  MSI,
  /// Machine timer IRQ
  MTI,
  /// Supervisor external IRQ
  SEI,
  /// Supervisor software IRQ
  SSI,
  /// Supervisor timer IRQ
  STI,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Exception {
  IllegalInstruction(VirtAddr, Bytecode, Bytecode16),
  LoadAccessFault(VirtAddr),
  StoreAccessFault(VirtAddr),
  LoadAddressMisaligned(VirtAddr),
  StoreAddressMisaligned(VirtAddr),
  // TODO: remove this hack
  ValheimEbreak,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Trap {
  // TODO: remove this hack
  ValheimEbreak,
}

impl RV64Cpu {
  pub fn pending_interrupt(&mut self) -> Option<IRQ> {
    // 3.1.6.1 Privilege and Global Interrupt-Enable Stack in mstatus register
    // Global interrupt-enable bits, MIE and SIE, are provided for M-mode and S-mode respectively.
    // When a hart is executing in privilege mode x, interrupts are globally enabled
    // when xIE=1 and globally disabled when xIE=0.
    // Interrupts for lower-privilege modes, w<x, are always globally disabled
    // regardless of the setting of any global wIE bit for the lower-privilege mode.
    // Interrupts for higher-privilege modes, y>x, are always globally enabled
    // regardless of the setting of the global yIE bit for the higher-privilege mode.

    // Higher-privilege-level code can use separate per-interrupt enable bits
    // to disable selected higher-privilege-mode interrupts before ceding control
    // to a lower-privilege mode.
    let irq_enabled = match self.mode {
      PrivilegeMode::Machine => self.csrs.is_machine_irq_enabled_globally(),
      PrivilegeMode::Supervisor => self.csrs.is_supervisor_irq_enabled_globally(),
      PrivilegeMode::User => true,
    };

    if !irq_enabled {
      return None;
    }

    // 3.1.9 Machine Interrupt Registers (mip and mie)
    // The machine-level interrupt fixed-priority ordering rules were developed with the following rationale:
    // 1. Interrupts for higher privilege modes must be serviced before interrupts
    //    for lower privilege modes to support preemption.
    // 2. The platform-specific machine-level interrupt sources in bits 16 and above have
    //    platform-specific priority, but are typically chosen to have the highest service priority
    //    to support very fast local vectored interrupts.
    // 3. External interrupts are handled before internal (timer/software) interrupts
    //    as external interrupts are usually generated by devices that might require
    //    low interrupt service times.
    // 4. Software interrupts are handled before internal timer interrupts, because internal
    //    timer interrupts are usually intended for time slicing, where time precision is less important,
    //    whereas software interrupts are used for inter-processor messaging.
    //    Software interrupts can be avoided when high-precision timing is required,
    //    or high-precision timer interrupts can be routed via a different interrupt path.

    // In our implementation, external devices is only UART, currently. We may support
    // VirtIO disks, which is also a external devices.
    match self.bus.devices.iter().find(|dev| dev.is_interrupting()) {
      Some(dev) => {
        let _irq_id = ((dev.vendor_id() as u32) << 16) | (dev.device_id() as u32);
        // TODO: tell PLIC that we have an external irq
        // 3.1.9 Machine Interrupt Registers (mip and mie)
        // SEIP is writable in mip, and may be written by M-mode software to
        // indicate to S-mode that an external interrupt is pending. Additionally,
        // the platform-level interrupt controller may generate supervisor-level external interrupts.
        self.csrs.write_unchecked(MIP, self.csrs.read_unchecked(MIP) | SEIP_MASK);
      }
      // No external device is interrupting
      None => (),
    }

    // 3.1.9 Machine Interrupt Registers (mip and mie)
    // Multiple simultaneous interrupts destined for M-mode are handled
    // in the following decreasing priority order: MEI, MSI, MTI, SEI, SSI, STI.

    // only enable bit and pending bit are both set, an interrupt is treated as taken
    let mip = self.csrs.read_unchecked(MIP) & self.csrs.read_unchecked(MIE) ;

    // fast-path check
    if mip == 0 {
      return None;
    }

    if (mip & MEIP_MASK) != 0 {
      self.csrs.write_unchecked(MIP, self.csrs.read_unchecked(MIP) & !MEIP_MASK);
      return Some(IRQ::MEI);
    }

    if (mip & MSIP_MASK) != 0 {
      self.csrs.write_unchecked(MIP, self.csrs.read_unchecked(MIP) & !MSIP_MASK);
      return Some(IRQ::MSI);
    }

    if (mip & MTIP_MASK) != 0 {
      self.csrs.write_unchecked(MIP, self.csrs.read_unchecked(MIP) & !MTIP_MASK);
      return Some(IRQ::MTI);
    }

    if (mip & SEIP_MASK) != 0 {
      self.csrs.write_unchecked(MIP, self.csrs.read_unchecked(MIP) & !SEIP_MASK);
      return Some(IRQ::SEI);
    }

    if (mip & SSIP_MASK) != 0 {
      self.csrs.write_unchecked(MIP, self.csrs.read_unchecked(MIP) & !SSIP_MASK);
      return Some(IRQ::SSI);
    }

    if (mip & STIP_MASK) != 0 {
      self.csrs.write_unchecked(MIP, self.csrs.read_unchecked(MIP) & !STIP_MASK);
      return Some(IRQ::STI);
    }

    None
  }
}

impl IRQ {
  pub fn handle(&self, cpu: &mut RV64Cpu) -> Result<(), ()> {
    todo!()
  }
}
